<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="本文初次发表于InfoQ  深入理解 iOS 图文混排原理并自定义图文控件  iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助NSAttributedString来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILab">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解图文混排原理并自定义图文控件">
<meta property="og:url" content="http://example.com/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/index.html">
<meta property="og:site_name" content="C.J.Lian">
<meta property="og:description" content="本文初次发表于InfoQ  深入理解 iOS 图文混排原理并自定义图文控件  iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助NSAttributedString来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILab">
<meta property="og:locale">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E5%9D%90%E6%A0%87.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E8%A1%8C%E9%AB%98.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CTRun%E8%AF%B4%E6%98%8E.jpg">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E8%AF%B4%E6%98%8E.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94.gif">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6.gif">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F.png">
<meta property="article:published_time" content="2019-10-24T03:50:03.000Z">
<meta property="article:modified_time" content="2019-10-25T04:15:00.000Z">
<meta property="article:author" content="lele8446">
<meta property="article:tag" content="Runtime">
<meta property="article:tag" content="CoreText">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png">


<link rel="canonical" href="http://example.com/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-Hans&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2019&#x2F;10&#x2F;24&#x2F;%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;10&#x2F;24&#x2F;深入理解图文混排原理并自定义图文控件&#x2F;&quot;,&quot;title&quot;:&quot;深入理解图文混排原理并自定义图文控件&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>深入理解图文混排原理并自定义图文控件 | C.J.Lian</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">C.J.Lian</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%96%87%E7%BB%98%E5%88%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">图文绘制架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoreGraphics"><span class="nav-number">2.</span> <span class="nav-text">CoreGraphics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoreText%E6%A1%86%E6%9E%B6"><span class="nav-number">3.</span> <span class="nav-text">CoreText框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFramesetter"><span class="nav-number">3.1.</span> <span class="nav-text">CTFramesetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFrame"><span class="nav-number">3.2.</span> <span class="nav-text">CTFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTLine"><span class="nav-number">3.3.</span> <span class="nav-text">CTLine</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTRun"><span class="nav-number">3.4.</span> <span class="nav-text">CTRun</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTRunDelegate"><span class="nav-number">3.5.</span> <span class="nav-text">CTRunDelegate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E6%8E%A7%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">自定义图文混排控件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.</span> <span class="nav-text">绘制关键点说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94"><span class="nav-number">4.2.</span> <span class="nav-text">点击响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E3%80%81%E5%A4%8D%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">选择、复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">写在最后</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lele8446"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">lele8446</p>
  <div class="site-description" itemprop="description">coding, learning...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/lele8446" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lele8446" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lele8446@foxmail.com" title="E-Mail → mailto:lele8446@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/%E7%82%BD%E9%87%91-%E7%BB%83-966a4813b/" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;%E7%82%BD%E9%87%91-%E7%BB%83-966a4813b&#x2F;" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="lele8446">
      <meta itemprop="description" content="coding, learning...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="C.J.Lian">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解图文混排原理并自定义图文控件
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-24 11:50:03" itemprop="dateCreated datePublished" datetime="2019-10-24T11:50:03+08:00">2019-10-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2019-10-25 12:15:00" itemprop="dateModified" datetime="2019-10-25T12:15:00+08:00">2019-10-25</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>本文初次发表于<a target="_blank" rel="noopener" href="https://www.infoq.cn/"><strong>InfoQ</strong> </a> <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/cy916KUJYK7GA3p2VjZH">深入理解 iOS 图文混排原理并自定义图文控件</a></p>
</blockquote>
<p>iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助<code>NSAttributedString</code>来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILabel绘制NSAttributedString不能灵活定位文本内的点击锚点区域，转换为HTML展示则带来Native与Web端交互成本以及WKWebView自身的性能问题。</p>
<p>那么，是否能有一种控件，在满足富文本图文混排的同时还能响应自定义锚点点击事件？要实现以上需求，我们首先从iOS图文展示原理说起。</p>
<span id="more"></span>

<h3 id="图文绘制架构"><a href="#图文绘制架构" class="headerlink" title="图文绘制架构"></a>图文绘制架构</h3><p>iOS7之后的图文绘制架构如下图所示，越往上封装程度越高，但可定制程度也越低，本文涉及讲解的主要是<code>CoreText</code>以及<code>CoreGraphics</code>层级 。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png" alt="CoreText架构"></p>
<h3 id="CoreGraphics"><a href="#CoreGraphics" class="headerlink" title="CoreGraphics"></a>CoreGraphics</h3><p>从下往上说，首先是<strong>CoreGraphics</strong>。这是一个C语言接口的核心图形库，而且它是跨平台的类库，iOS和macOS系统均可使用。虽然它很偏底层，但很多情况下其实你已经使用过它了：比如<strong>CGAffineTransform</strong>用于形变，<strong>CGBitmapContext</strong>用于截图或者图片绘制，<strong>CGContext</strong>用于获取上下文进行直线、曲线、不规则图形绘制等。</p>
<p>这里着重说明下<strong>CGContext</strong>上下文。上下文类似于进行绘画时候的画布，使用<code>UIGraphicsGetCurrentContext()</code>可以快捷得到当前上下文，同时需要注意在CoreText下坐标系的原点为视图的左下角，x轴向右为正方向，y轴向上为正方向。而UIKit坐标系的原点是视图的左上角，x轴向右为正方向，y轴向下为正方向，所以我们在进行图文绘制前需要进行坐标反转，如图所示：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E5%9D%90%E6%A0%87.png" alt="CoreText坐标"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取上下文</span></span><br><span class="line"><span class="built_in">CGContextRef</span> c = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="comment">// 将当前图形状态推入堆栈</span></span><br><span class="line"><span class="built_in">CGContextSaveGState</span>(c);</span><br><span class="line"><span class="comment">// 设置字形变换矩阵为CGAffineTransformIdentity，也就是说每一个字形都不做图形变换</span></span><br><span class="line"><span class="built_in">CGContextSetTextMatrix</span>(c, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line"><span class="comment">// 坐标转换，UIKit 坐标原点在左上角，CoreText 坐标原点在左下角</span></span><br><span class="line"><span class="built_in">CGContextTranslateCTM</span>(c, <span class="number">0.0</span>f, insetRect.size.height);</span><br><span class="line"><span class="built_in">CGContextScaleCTM</span>(c, <span class="number">1.0</span>f, <span class="number">-1.0</span>f);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>进行图文绘制操作</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 绘制完成，将堆栈顶部的状态弹出，返回到之前的图形状态</span></span><br><span class="line"><span class="built_in">CGContextRestoreGState</span>(c);</span><br></pre></td></tr></table></figure>

<p>以上使用CoreGraphics进行图文绘制的过程，可以在<code>drawRect:</code>或 <code>drawTextInRect:</code>等相关方法中进行操作。</p>
<h3 id="CoreText框架"><a href="#CoreText框架" class="headerlink" title="CoreText框架"></a>CoreText框架</h3><p><strong>CoreText</strong>是iOS中用于文本绘制的引擎，其位于<code>UIKit</code>中和<code>CoreGraphics/Quartz</code>之间。查看开发文档，可以看到CoreText架构主要包含以下类，其中标红部分是图文绘制需要使用到的相关类，我们逐个介绍。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText.png" alt="CoreText"></p>
<h4 id="CTFramesetter"><a href="#CTFramesetter" class="headerlink" title="CTFramesetter"></a>CTFramesetter</h4><p>CTFramesetter是管理生成CTFrame的工厂类，其中记录了需要绘制的文本内容中不同字符串对应的富文本属性（加粗、颜色、字号等），通过NSAttributedString可生成CTFrameSetter。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];</span><br><span class="line"><span class="comment">//生成CTFramesetter</span></span><br><span class="line"><span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedStr);</span><br><span class="line"><span class="built_in">CFRelease</span>(framesetter);</span><br></pre></td></tr></table></figure>

<h4 id="CTFrame"><a href="#CTFrame" class="headerlink" title="CTFrame"></a>CTFrame</h4><p>CTFrame描述了总的文本绘制区域的<code>frame</code>，通过它你可以得到在指定区域内绘制的文本一共有多少行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//生成绘制区域路径</span></span><br><span class="line"><span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line"><span class="built_in">CGPathAddRect</span>(path, <span class="literal">NULL</span>, rect);</span><br><span class="line"><span class="comment">//生成CTFrame</span></span><br><span class="line"><span class="built_in">CTFrameRef</span> frame = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [attributedStr length]), path, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一共有多少行</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> lines = <span class="built_in">CTFrameGetLines</span>(frame);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(frame);</span><br><span class="line"><span class="built_in">CGPathRelease</span>(path);</span><br></pre></td></tr></table></figure>

<h4 id="CTLine"><a href="#CTLine" class="headerlink" title="CTLine"></a>CTLine</h4><p>CTLine记录了需要绘制的单行文本信息，通过它你可以得到当前行的上行高、下行高以及行间距等信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第一行信息</span></span><br><span class="line"><span class="built_in">CTLineRef</span> line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//上行高、下行高、行间距</span></span><br><span class="line"><span class="built_in">CGFloat</span> lineAscent = <span class="number">0.0</span>f, lineDescent = <span class="number">0.0</span>f, lineLeading = <span class="number">0.0</span>f;</span><br><span class="line"><span class="comment">//获取行宽、行高信息</span></span><br><span class="line"><span class="built_in">CGFloat</span> lineWidth = <span class="built_in">CTLineGetTypographicBounds</span>(line, &amp;lineAscent, &amp;lineDescent, &amp;lineLeading);</span><br></pre></td></tr></table></figure>

<p>关于行文本的上下行高、行间距、原点、基线等的说明，可参照下图：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E8%A1%8C%E9%AB%98.png" alt="行高"></p>
<p>系统绘制文本的时候，首先会以基线（Baseline）为基准，从当前行的基线最左侧的原点（Origin）开始，计算得到上行高（Ascent），下行高（Descent），不同行之间的行间距（Leading），以及行宽信息。</p>
<h4 id="CTRun"><a href="#CTRun" class="headerlink" title="CTRun"></a>CTRun</h4><p>CTRun描述了单行文本中具有相同富文本属性的字符实体，每一行文字中可能有多个CTRun，也有可能只包含一个CTRun。如下图，这行文字中包含三个CTRun，分别为：<code>这是</code>     <code>一段</code>  <code>测试数据</code></p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CTRun%E8%AF%B4%E6%98%8E.jpg" alt="CTRun说明"></p>
<p>与CTLine一样，同样可以计算得到单个CTRun的绘制区域大小。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化CTRun的区域大小为CGRectZero</span></span><br><span class="line"><span class="built_in">CGRect</span> runBounds = <span class="built_in">CGRectZero</span>;</span><br><span class="line"><span class="comment">//初始化CTRun的上行高、下行高、行间距</span></span><br><span class="line"><span class="built_in">CGFloat</span> runAscent = <span class="number">0.0</span>f, runDescent = <span class="number">0.0</span>f, runLeading = <span class="number">0.0</span>f;</span><br><span class="line"><span class="comment">//计算得到上下行高、行间距以及CTRun绘制区域宽度</span></span><br><span class="line">runBounds.size.width = (<span class="built_in">CGFloat</span>)<span class="built_in">CTRunGetTypographicBounds</span>(glyphRun, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;runAscent, &amp;runDescent, &amp;runLeading);</span><br><span class="line"><span class="comment">//计算高度，注意下行高为负数的情况</span></span><br><span class="line"><span class="built_in">CGFloat</span> runHeight = runAscent + fabs(runDescent);</span><br><span class="line">runBounds.size.height = runHeight;</span><br></pre></td></tr></table></figure>

<h4 id="CTRunDelegate"><a href="#CTRunDelegate" class="headerlink" title="CTRunDelegate"></a>CTRunDelegate</h4><p>CTRunDelegate用于图文混排时候的图片绘制，因为CoreText本身并不能进行图文混排，但是可以使用CTRunDelegate在需要显示图片的地方添加占位符，当CoreText绘制到该位置的时候，会触发CTRunDelegate代理，在代理方法中可以获取到该区域的大小以及图片信息，然后调用 <code>CGContextDrawImage(c, runBounds, image.CGImage)</code> 绘制图片即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *imgInfoDic = @&#123;kCJImage:image,<span class="comment">//需要绘制的图片</span></span><br><span class="line">                             kCJImageWidth:@(size.width),<span class="comment">//需要绘制的图片区域宽度</span></span><br><span class="line">                             kCJImageHeight:@(size.height),<span class="comment">//需要绘制的图片区域高度&#125;;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//创建CTRunDelegateRef并设置回调函数</span></span><br><span class="line"><span class="built_in">CTRunDelegateCallbacks</span> imageCallbacks;</span><br><span class="line">imageCallbacks.version = kCTRunDelegateVersion1;</span><br><span class="line">imageCallbacks.dealloc = RunDelegateDeallocCallback;</span><br><span class="line">imageCallbacks.getWidth = RunDelegateGetWidthCallback;<span class="comment">//图片区域宽度回调</span></span><br><span class="line">imageCallbacks.getAscent = RunDelegateGetAscentCallback;<span class="comment">//图片区域上行高回调</span></span><br><span class="line">imageCallbacks.getDescent = RunDelegateGetDescentCallback;<span class="comment">//图片区域下行高回调</span></span><br><span class="line"><span class="built_in">CTRunDelegateRef</span> runDelegate = <span class="built_in">CTRunDelegateCreate</span>(&amp;imageCallbacks, (__bridge <span class="keyword">void</span> *)imgInfoDic);</span><br><span class="line"><span class="comment">//初始化空白占位字符</span></span><br><span class="line"><span class="keyword">unichar</span> imgReplacementChar = <span class="number">0xFFFC</span>;</span><br><span class="line"><span class="built_in">NSString</span> *imgReplacementString = [<span class="built_in">NSString</span> stringWithCharacters:&amp;imgReplacementChar length:<span class="number">1</span>];</span><br><span class="line"><span class="comment">//插入图片 空白占位符</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *imgPlaceholderStr = [[<span class="built_in">NSMutableString</span> alloc]initWithCapacity:<span class="number">3</span>];</span><br><span class="line">[imgPlaceholderStr appendString:imgReplacementString];</span><br><span class="line"><span class="built_in">NSRange</span> imgRange = <span class="built_in">NSMakeRange</span>(<span class="number">0</span>, imgPlaceholderStr.length);</span><br><span class="line"><span class="built_in">NSMutableAttributedString</span> *imageAttributedString = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:imgPlaceholderStr];</span><br><span class="line"><span class="comment">//将CTRunDelegate记录到NSMutableAttributedString的富文本信息中</span></span><br><span class="line">[imageAttributedString addAttribute:(<span class="built_in">NSString</span> *)kCTRunDelegateAttributeName value:(__bridge <span class="keyword">id</span>)runDelegate range:imgRange];</span><br><span class="line"><span class="comment">//kCJImageAttributeName为自定义的记录图片信息的富文本属性</span></span><br><span class="line">[imageAttributedString addAttribute:kCJImageAttributeName value:imgInfoDic range:imgRange];</span><br></pre></td></tr></table></figure>



<p>看完上面的概念介绍，相信你已经对iOS的图文绘制原理有了基础的认识，以上各个类的关联关系如图所示：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E8%AF%B4%E6%98%8E.png" alt="CoreText说明">完整的绘制流程如下：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="绘制流程"></p>
<h3 id="自定义图文混排控件"><a href="#自定义图文混排控件" class="headerlink" title="自定义图文混排控件"></a>自定义图文混排控件</h3><p>自定义图文混排控件，可以基于UILabel来实现，UILabel本身已支持NSAttributedString富文本展示，我们只需在原有基础上扩展指定字符区域背景色、插入图片（或自定义view）展示、指定锚点点击响应事件、点击时候的字符高亮展示等功能即可。</p>
<h4 id="绘制关键点说明"><a href="#绘制关键点说明" class="headerlink" title="绘制关键点说明"></a>绘制关键点说明</h4><p>首先在设置NSAttributedString富文本属性的时候，增加自定义属性。NSAttributedString的富文本属性Attributes其实就是字典，那么可以在其中添加自定义的key-value配置，类似以下说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 删除线宽度。值为NSNumber。默认 `0.0f`，表示无删除线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCJStrikethroughStyleAttributeName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 删除线颜色。值为UIColor。默认 `[UIColor blackColor]`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCJStrikethroughColorAttributeName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 对NSAttributedString文本设置锚点属性时候的唯一标识</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCJLinkStringIdentifierAttributesName;</span><br></pre></td></tr></table></figure>

<p>第二步就是在遍历获取CTRun时，将属于锚点的CTRun的<code>frame</code>区域信息记录起来，同时还要记录该锚点对应的扩展参数，以及合并具有相同属性的CTRun。</p>
<p>第三步是绘制字符，如果包含自定义属性，那么需要调用CoreGraphics的相关方法进行扩展属性的设置，比如先填充背景色<code>CGContextSetFillColorWithColor(c,color);</code> 再绘制文字<code>CTRunDraw(runRef, c, CFRangeMake(0, 0));</code>  再添加边框线、删除线<code>CGContextSetStrokeColorWithColor(c,color);</code> 你可以把这个过程想象是成在一张画布上绘画，绘制时候需要注意不同图层的层级关系，不然上面的图层会将下面的图层覆盖。</p>
<p>最后一步是图片展示，如果CTRun是包含CTRunDelegate的显示区域，那么系统会将你设置好大小的区域空白出来，你只需在该位置上画出图片即可：<code>CGContextDrawImage(c, runBounds, image.CGImage);</code>另外我还在此基础上做了扩展，不单单支持图文混排，还可以在指定区域上插入任意UIView。原理是同样借助CTRunDelegate在对应位置上预留出指定大小的空白区域，然后将需要插入的UIView存储在NSAttributedString的Attributes属性中，当绘制到该位置时只需调用<code>[self addSubview:view];</code>即可。</p>
<h4 id="点击响应"><a href="#点击响应" class="headerlink" title="点击响应"></a>点击响应</h4><p>UILabel继承自UIView和UIResponder，那么可以基于iOS的事件响应链机制来实现锚点点击事件。</p>
<p>重写<code>hitTest: withEvent:</code>方法，在其中判断是否需要响应点击事件，否则将响应事件向下传递。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// ![self linkAtPoint:point extendsLinkTouchArea:NO]表示不在锚点点击范围内</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> linkAtPoint:point extendsLinkTouchArea:<span class="literal">NO</span>] || !<span class="keyword">self</span>.userInteractionEnabled || <span class="keyword">self</span>.hidden || <span class="keyword">self</span>.alpha &lt; <span class="number">0.01</span>) &#123;</span><br><span class="line">        <span class="comment">//如果支持选择复制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.enableCopy) &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于如何判断是否在锚点点击范围内，可参照<code>linkAtPoint: extendsLinkTouchArea:</code>伪函数说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (CJGlyphRunStrokeItem *)linkAtPoint:(<span class="built_in">CGPoint</span>)point extendsLinkTouchArea:(<span class="built_in">BOOL</span>)extendsLinkTouchArea &#123;</span><br><span class="line">    <span class="comment">// CJGlyphRunStrokeItem 对应 CTRun，其中记录了字符区域（bounds）的大小</span></span><br><span class="line">    CJGlyphRunStrokeItem *resultItem = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// _linkStrokeItemArray 表示记录了所有锚点信息的数组</span></span><br><span class="line">    <span class="keyword">for</span> (CJGlyphRunStrokeItem *item <span class="keyword">in</span> _linkStrokeItemArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(item.bounds, point)) &#123;</span><br><span class="line">            resultItem = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写touches系列方法，首先在<code>touchesBegan: withEvent:</code>中判断是否点击了锚点区域，如果是则触发重绘以达到点击高亮效果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    CJGlyphRunStrokeItem *item = [<span class="keyword">self</span> linkAtPoint:[touch locationInView:<span class="keyword">self</span>] extendsLinkTouchArea:<span class="keyword">self</span>.extendsLinkTouchArea];</span><br><span class="line">    <span class="comment">//点击锚点存在</span></span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 触发重绘操作，达到点击锚点高亮效果</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>touchesEnded: withEvent:</code>中处理点击事件的响应操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">//  如果是长按点击，交由长按点击手势UILongPressGestureRecognizer响应</span></span><br><span class="line">    <span class="keyword">if</span> (_longPress) &#123;</span><br><span class="line">        [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentClickRunStrokeItem) &#123;</span><br><span class="line">            <span class="comment">// 如果当前是点击锚点事件，抛出点击回调事件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(CJLable:didClickLink:)]) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.delegate CJLable:<span class="keyword">self</span> didClickLink:linkModel];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 再次重绘，还原点击前的文本显示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，如果是双击点击事件或者长按点击事件，那么在touches系列的回调方法中是不能处理的，交互处理应该放到<code>UITapGestureRecognizer</code>和<code>UILongPressGestureRecognizer</code>的响应方法中判断。另外手势事件的响应方法中是无法得到当前点击位置的点坐标<code>CGPoint</code>的，这里用到了比较取巧的方式（通过Rumtime关联属性）达到了判断点击响应的效果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在此时刚接收到手势事件的回调中，将UITouch关联到 UIGestureRecognizer实例</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123;</span><br><span class="line">    <span class="keyword">if</span> (gestureRecognizer == <span class="keyword">self</span>.longPressGestureRecognizer) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>.longPressGestureRecognizer, &amp;kAssociatedUITouchKey, touch, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (gestureRecognizer == <span class="keyword">self</span>.doubleTapGes) &#123;</span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>.doubleTapGes, &amp;kAssociatedUITouchKey, touch, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 双击点击事件</span></span><br><span class="line">- (<span class="keyword">void</span>)tapTwoAct:(<span class="built_in">UITapGestureRecognizer</span> *)sender &#123;</span><br><span class="line">    <span class="comment">// Runtime属性关联，获取到对应的UITouch，并计算得到点击坐标：[touch locationInView:self]</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = objc_getAssociatedObject(<span class="keyword">self</span>.doubleTapGes, &amp;kAssociatedUITouchKey);</span><br><span class="line">    CJGlyphRunStrokeItem *item = [<span class="keyword">self</span> linkAtPoint:[touch locationInView:<span class="keyword">self</span>] extendsLinkTouchArea:<span class="keyword">self</span>.extendsLinkTouchArea];</span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 如果当前是双击点击锚点事件，抛出点击回调事件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(CJLable:didClickLink:)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate CJLable:<span class="keyword">self</span> didClickLink:linkModel];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 再次重绘，还原点击前的文本显示</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是点击锚点且开启了选择复制功能</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.enableCopy) &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 显示选择复制提示视图</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长按点击事件</span></span><br><span class="line">- (<span class="keyword">void</span>)longPressGestureDidFire:(<span class="built_in">UILongPressGestureRecognizer</span> *)sender &#123;</span><br><span class="line">    <span class="comment">// Runtime属性关联，获取到对应的UITouch，并计算得到点击坐标：[touch locationInView:self]</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = objc_getAssociatedObject(<span class="keyword">self</span>.longPressGestureRecognizer, &amp;kAssociatedUITouchKey);</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="built_in">BOOL</span> isLinkItem = [<span class="keyword">self</span> containslinkAtPoint:[touch locationInView:<span class="keyword">self</span>]];</span><br><span class="line">    <span class="keyword">switch</span> (sender.state) &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 如果当前是长按锚点事件，抛出长按回调事件</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLinkItem) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.delegate &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(CJLable:didLongPressLink:)]) &#123;</span><br><span class="line">                        [<span class="keyword">self</span>.delegate CJLable:<span class="keyword">self</span> didLongPressLink:linkModel];</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是点击锚点且开启了选择复制功能</span></span><br><span class="line">    		<span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">if</span> (<span class="keyword">self</span>.enableCopy) &#123;</span><br><span class="line">            		<span class="comment">//<span class="doctag">TODO:</span> 长按显示放大镜</span></span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:&#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> 再次重绘，还原长按前的文本显示</span></span><br><span class="line">            <span class="comment">//如果支持复制</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.enableCopy) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> 显示选择复制提示视图</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>:</span><br><span class="line">    		<span class="comment">//如果支持复制</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.enableCopy) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag">TODO:</span> 更新放大镜位置，以及更新选择复制区域</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下自定义点击控件的效果图</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94.gif" alt="点击响应"></p>
<h4 id="选择、复制"><a href="#选择、复制" class="headerlink" title="选择、复制"></a>选择、复制</h4><p>自定义图文混排控件还可以支持选择复制功能，当然这里说的选择复制不是指点击唤起<code>UIMenuController</code>菜单，然后出现复制剪切选项，点击则只能复制所有文本。那样的例子网上已经有很多，没有必要在这里再大费周章地罗列说明。 其需要具备的是类似于UITextView或UIWebView那样双击或长按，可出现<code>拷贝、选择、全选</code>选项，同时选中字符左右出现指示大头针，拖动则有放大镜提示当前选中的字符，并且要尽量做到与系统行为一致。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6.gif" alt="选择复制"></p>
<p>需求细化后选择复制的要点主要包含以下：</p>
<ul>
<li>选中字符后出现<code>拷贝、选择 全选 </code>菜单，这个使用系统的<code>UIMenuController</code>功能即可实现，不存在难点问题。</li>
<li>对于选中的文字，起始要有大头针标识，中间填充浅蓝色背景，而且这一部分区域会是一块不规则多边形。系统没有提供现成可复用的对应UI控件，但只要我们能够判断到选中区域，就能在左右画上大头针，中间填充颜色，所以这一块也不存在问题。</li>
<li>拖动选择的过程中，出现放大镜来提示选中字符的更改。在能够准确获取到当前触摸点坐标的前提下，只需要将触摸点周围区域的图层截取并作<code>CGContextScaleCTM</code>缩放，然后再将放大后的图层显示出来即可，所以这个也是可以实现的。</li>
<li>最后便是重点了，如何判断每一个字符对应的<code>frame</code>坐标位置，并要求在手指移动时能够准确判断选择区域的变化。</li>
</ul>
<p>前面已经讲到，单行文本中具有相同富文本属性的字符会被绘制到同一个<code>CTRun</code>中，而通过<code>CTRun</code>可以计算得到它的<code>frame</code>大小。那么重点则变成如何使得每一个字符（图片或插入UIView）对应一个<code>CTRun</code>。</p>
<p>解决很简单：只要保证NSAttributedString中每一个字符的Attributes属性不一样就可以了。我开始的做法是添加一个自定义属性<code>kCJIndexAttributesName</code>，然后给每个字符存储不同的index值，并且在全部图文遍历绘制过一次后将<code>kCJIndexAttributesName</code>移除，这样在后续的重绘中就会减少<code>CTRun</code>的拆分数量，提高了效率。</p>
<p>然而，理想很美好，现实很打击。就算自定义属性<code>kCJIndexAttributesName</code>移除了，可<code>CTRun</code>还是会被拆分为单个字符，但是如果使用系统自带的属性则不会如此。无奈只能从系统方法中寻找解决思路，幸好发现了<code>NSLinkAttributeName</code>属性，这是UITextView中用来设置http链接的扩展属性，存储的对象是<code>NSURL</code>或<code>NSString</code>类型，而UILabel默认是不支持http链点的，使用<code>NSLinkAttributeName</code>属性可以最大限度的降低UILabel对默认NSAttributedString展示的影响。同时为了更好的判断计算，我将存储的对象改为NSURL的子类<code>CJCTRunUrl</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给每一个字符设置index值，enableCopy=YES时生效</span></span><br><span class="line">__block <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line">[attText.string enumerateSubstringsInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, [attText length]) options:<span class="built_in">NSStringEnumerationByComposedCharacterSequences</span> usingBlock:</span><br><span class="line"> ^(<span class="built_in">NSString</span> *substring, <span class="built_in">NSRange</span> substringRange, <span class="built_in">NSRange</span> enclosingRange, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">     CJCTRunUrl *runUrl = <span class="literal">nil</span>;</span><br><span class="line">     <span class="keyword">if</span> (!runUrl) &#123;</span><br><span class="line">         <span class="built_in">NSString</span> *urlStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;https://www.CJLabel%@&quot;</span>,@(index)];</span><br><span class="line">         runUrl = [CJCTRunUrl URLWithString:urlStr];</span><br><span class="line">     &#125;</span><br><span class="line">     runUrl.index = index;</span><br><span class="line">     runUrl.rangeValue = [<span class="built_in">NSValue</span> valueWithRange:substringRange];</span><br><span class="line">     [attText addAttribute:<span class="built_in">NSLinkAttributeName</span></span><br><span class="line">                     value:runUrl</span><br><span class="line">                     range:substringRange];</span><br><span class="line">     index++;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>

<p>选择复制视图展示的交互逻辑则在双击或长按手势中实现，前面 <strong>点击响应</strong> 的伪代码示意中已经说明。另外讲解一下选择复制视图的实现细节：</p>
<p>其中的<code>拷贝、选择、全选</code>菜单使用系统提供的<code>UIMenuController</code>实现，在双击或长按时只要将它显示到手指点击对应的位置上就行。</p>
<p>放大镜则是自定义UIView，并在上面添加一个<code>CALayer</code>，再在<code>CALayer</code>上根据更新的点坐标做放大效果，<code>CALayer</code>的放大境处理逻辑如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)ctx &#123;</span><br><span class="line">	<span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="keyword">self</span>.frame.size.width/<span class="number">2</span>, <span class="keyword">self</span>.frame.size.height/<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">CGContextScaleCTM</span>(ctx, <span class="number">1.40</span>, <span class="number">1.40</span>);</span><br><span class="line">	<span class="comment">//self.pointToMagnify是更新的放大点坐标</span></span><br><span class="line">	<span class="built_in">CGContextTranslateCTM</span>(ctx, <span class="number">-1</span> * <span class="keyword">self</span>.pointToMagnify.x, <span class="number">-1</span> * <span class="keyword">self</span>.pointToMagnify.y);</span><br><span class="line">	[CJkeyWindow().layer renderInContext:ctx];</span><br><span class="line">	CJkeyWindow().layer.contents = (<span class="keyword">id</span>)<span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大头针包含的提示用户选中区域，同样由自定义UIView实现，在自定义view上面填充颜色以及在起始结束位置画出大头针，其中的填充颜色区域包含三部分<code>headRect</code> <code>middleRect</code> <code>tailRect</code></p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F.png" alt="选择区域"></p>
<p>这三部分存在任意组合的情况，填充颜色的时候要对这三部分区分开来分别进行填充。因为有可能存在只有<code>headRect</code> <code>middleRect</code> 或只有<code>middleRect</code> <code>tailRect</code>，又或者只有 <code>middleRect</code> 的情况，而且填充颜色使用的是<code>CoreGraphics</code>中的绘图API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="comment">//填充的背景色</span></span><br><span class="line"><span class="built_in">UIColor</span> *backColor = CJUIRGBColor(<span class="number">0</span>,<span class="number">84</span>,<span class="number">166</span>,<span class="number">0.2</span>);</span><br><span class="line">[backColor set];</span><br><span class="line"><span class="built_in">CGContextAddRect</span>(ctx, <span class="keyword">self</span>.headRect);</span><br><span class="line"><span class="built_in">CGContextStrokePath</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>接下来便是如何显示这三个选择复制相关的视图了，一开始我只是简单的将它们添加到<code>Label</code>上面来统一管理，但这样会存在一个问题。那就是当页面中存在多个<code>Label</code>，并且对每个<code>Label</code>分别执行选择复制操作时，那么不同的<code>label</code>上都会出现选择复制视图，这是与系统的默认行为是不一致的。权衡之后将以上三个视图的显示作为单例处理，全局只初始化一次，避免了重复初始化的开销。并且将它添加到<code>UIWindow</code>层，这样在不同的<code>Label</code>之间进行选择复制时，也只会显示一个选择复制视图。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>以上便是iOS图文绘制原理以及自定义图文控件的说明，关键点是充分理解你看到的每一个字符在底层绘制显示的时候与<code>CTFrame</code> <code>CTLine</code> <code>CTRun</code>等实体类的对应关系，并借助其计算得到每一个字符的区域<code>frame</code>信息，有了区域<code>frame</code>信息便能够扩展实现各种自定义功能（点击响应、插入图片、选择拷贝等）。</p>
<p>全文完，更多的实现可以查看源码<a target="_blank" rel="noopener" href="https://github.com/lele8446/CJLabel">CJLabel</a>。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Runtime/" rel="tag"># Runtime</a>
              <a href="/tags/CoreText/" rel="tag"># CoreText</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/09/07/iOS12%20%E8%B8%A9%E5%9D%91%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/" rel="prev" title="iOS12 踩坑持续更新">
                  <i class="fa fa-chevron-left"></i> iOS12 踩坑持续更新
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/12/24/%E6%8E%A7%E5%88%B6UIScrollView%E6%BB%91%E5%8A%A8%E6%96%B9%E5%90%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="next" title="控制UIScrollView滑动方向解决方案">
                  控制UIScrollView滑动方向解决方案 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lele8446</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
