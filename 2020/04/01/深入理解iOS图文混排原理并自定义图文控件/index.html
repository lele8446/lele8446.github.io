<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="##深入理解iOS图文混排原理并自定义图文控件 iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助NSAttributedString来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILabel绘制NSAttributed">
<meta property="og:type" content="article">
<meta property="og:title" content="C.J.Lian">
<meta property="og:url" content="http://example.com/2020/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/index.html">
<meta property="og:site_name" content="C.J.Lian">
<meta property="og:description" content="##深入理解iOS图文混排原理并自定义图文控件 iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助NSAttributedString来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILabel绘制NSAttributed">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E5%9D%90%E6%A0%87.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E8%A1%8C%E9%AB%98.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CTRun%E8%AF%B4%E6%98%8E.jpg">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E8%AF%B4%E6%98%8E.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94.gif">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6.gif">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F.png">
<meta property="article:published_time" content="2020-04-01T03:19:27.000Z">
<meta property="article:modified_time" content="2020-04-01T03:19:27.000Z">
<meta property="article:author" content="lele8446">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/04/01/深入理解iOS图文混排原理并自定义图文控件/"/>





  <title> | C.J.Lian</title>
  














<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">C.J.Lian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="C.J.Lian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-01T11:19:27+08:00">
                2020-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>##深入理解iOS图文混排原理并自定义图文控件</p>
<p>iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助<code>NSAttributedString</code>来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILabel绘制NSAttributedString不能灵活定位文本内的点击锚点区域，转换为HTML展示则带来Native与Web端交互成本以及WKWebView自身的性能问题。</p>
<p>那么，是否能有一种控件，在满足富文本图文混排的同时还能响应自定义锚点点击事件？要实现以上需求，我们首先从iOS图文展示原理说起。</p>
<p>###图文绘制架构</p>
<p>iOS7之后的图文绘制架构如下图所示，越往上封装程度越高，但可定制程度也越低，本文涉及讲解的主要是<code>CoreText</code>以及<code>CoreGraphics</code>层级 。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png" alt="CoreText架构"></p>
<p>###CoreGraphics</p>
<p>从下往上说，首先是<strong>CoreGraphics</strong>。这是一个C语言接口的核心图形库，而且它是跨平台的类库，iOS和macOS系统均可使用。虽然它很偏底层，但很多情况下其实你已经使用过它了：比如<strong>CGAffineTransform</strong>用于形变，<strong>CGBitmapContext</strong>用于截图或者图片绘制，<strong>CGContext</strong>用于获取上下文进行直线、曲线、不规则图形绘制等。</p>
<p>这里着重说明下<strong>CGContext</strong>上下文。上下文类似于进行绘画时候的画布，使用<code>UIGraphicsGetCurrentContext()</code>可以快捷得到当前上下文，同时需要注意在CoreText下坐标系的原点为视图的左下角，x轴向右为正方向，y轴向上为正方向。而UIKit坐标系的原点是视图的左上角，x轴向右为正方向，y轴向下为正方向，所以我们在进行图文绘制前需要进行坐标反转，如图所示：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E5%9D%90%E6%A0%87.png" alt="CoreText坐标"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取上下文</span><br><span class="line">CGContextRef c &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">&#x2F;&#x2F; 将当前图形状态推入堆栈</span><br><span class="line">CGContextSaveGState(c);</span><br><span class="line">&#x2F;&#x2F; 设置字形变换矩阵为CGAffineTransformIdentity，也就是说每一个字形都不做图形变换</span><br><span class="line">CGContextSetTextMatrix(c, CGAffineTransformIdentity);</span><br><span class="line">&#x2F;&#x2F; 坐标转换，UIKit 坐标原点在左上角，CoreText 坐标原点在左下角</span><br><span class="line">CGContextTranslateCTM(c, 0.0f, insetRect.size.height);</span><br><span class="line">CGContextScaleCTM(c, 1.0f, -1.0f);</span><br><span class="line">&#x2F;&#x2F; TODO:进行图文绘制操作</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#x2F;&#x2F; 绘制完成，将堆栈顶部的状态弹出，返回到之前的图形状态</span><br><span class="line">CGContextRestoreGState(c);</span><br></pre></td></tr></table></figure>

<p>以上使用CoreGraphics进行图文绘制的过程，可以在<code>drawRect:</code>或 <code>drawTextInRect:</code>等相关方法中进行操作。</p>
<p>###CoreText框架</p>
<p><strong>CoreText</strong>是iOS中用于文本绘制的引擎，其位于<code>UIKit</code>中和<code>CoreGraphics/Quartz</code>之间。查看开发文档，可以看到CoreText架构主要包含以下类，其中标红部分是图文绘制需要使用到的相关类，我们逐个介绍。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText.png" alt="CoreText"></p>
<h4 id="CTFramesetter"><a href="#CTFramesetter" class="headerlink" title="CTFramesetter"></a>CTFramesetter</h4><p>CTFramesetter是管理生成CTFrame的工厂类，其中记录了需要绘制的文本内容中不同字符串对应的富文本属性（加粗、颜色、字号等），通过NSAttributedString可生成CTFrameSetter。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableAttributedString *attributedStr &#x3D; [[NSMutableAttributedString alloc] initWithString:text attributes:attributes];</span><br><span class="line">&#x2F;&#x2F;生成CTFramesetter</span><br><span class="line">CTFramesetterRef framesetter &#x3D; CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributedStr);</span><br><span class="line">CFRelease(framesetter);</span><br></pre></td></tr></table></figure>

<h4 id="CTFrame"><a href="#CTFrame" class="headerlink" title="CTFrame"></a>CTFrame</h4><p>CTFrame描述了总的文本绘制区域的<code>frame</code>，通过它你可以得到在指定区域内绘制的文本一共有多少行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CGRect rect &#x3D; CGRectMake(0, 0, 100, 100);</span><br><span class="line">&#x2F;&#x2F;生成绘制区域路径</span><br><span class="line">CGMutablePathRef path &#x3D; CGPathCreateMutable();</span><br><span class="line">CGPathAddRect(path, NULL, rect);</span><br><span class="line">&#x2F;&#x2F;生成CTFrame</span><br><span class="line">CTFrameRef frame &#x3D; CTFramesetterCreateFrame(framesetter, CFRangeMake(0, [attributedStr length]), path, NULL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取一共有多少行</span><br><span class="line">CFArrayRef lines &#x3D; CTFrameGetLines(frame);</span><br><span class="line"></span><br><span class="line">CFRelease(frame);</span><br><span class="line">CGPathRelease(path);</span><br></pre></td></tr></table></figure>

<p>####CTLine</p>
<p>CTLine记录了需要绘制的单行文本信息，通过它你可以得到当前行的上行高、下行高以及行间距等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取第一行信息</span><br><span class="line">CTLineRef line &#x3D; CFArrayGetValueAtIndex(lines, 0);</span><br><span class="line">&#x2F;&#x2F;上行高、下行高、行间距</span><br><span class="line">CGFloat lineAscent &#x3D; 0.0f, lineDescent &#x3D; 0.0f, lineLeading &#x3D; 0.0f;</span><br><span class="line">&#x2F;&#x2F;获取行宽、行高信息</span><br><span class="line">CGFloat lineWidth &#x3D; CTLineGetTypographicBounds(line, &amp;lineAscent, &amp;lineDescent, &amp;lineLeading);</span><br></pre></td></tr></table></figure>

<p>关于行文本的上下行高、行间距、原点、基线等的说明，可参照下图：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E8%A1%8C%E9%AB%98.png" alt="行高"></p>
<p>系统绘制文本的时候，首先会以基线（Baseline）为基准，从当前行的基线最左侧的原点（Origin）开始，计算得到上行高（Ascent），下行高（Descent），不同行之间的行间距（Leading），以及行宽信息。</p>
<h4 id="CTRun"><a href="#CTRun" class="headerlink" title="CTRun"></a>CTRun</h4><p>CTRun描述了单行文本中具有相同富文本属性的字符实体，每一行文字中可能有多个CTRun，也有可能只包含一个CTRun。如下图，这行文字中包含三个CTRun，分别为：<code>这是</code>     <code>一段</code>  <code>测试数据</code></p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CTRun%E8%AF%B4%E6%98%8E.jpg" alt="CTRun说明"></p>
<p>与CTLine一样，同样可以计算得到单个CTRun的绘制区域大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化CTRun的区域大小为CGRectZero</span><br><span class="line">CGRect runBounds &#x3D; CGRectZero;</span><br><span class="line">&#x2F;&#x2F;初始化CTRun的上行高、下行高、行间距</span><br><span class="line">CGFloat runAscent &#x3D; 0.0f, runDescent &#x3D; 0.0f, runLeading &#x3D; 0.0f;</span><br><span class="line">&#x2F;&#x2F;计算得到上下行高、行间距以及CTRun绘制区域宽度</span><br><span class="line">runBounds.size.width &#x3D; (CGFloat)CTRunGetTypographicBounds(glyphRun, CFRangeMake(0, 0), &amp;runAscent, &amp;runDescent, &amp;runLeading);</span><br><span class="line">&#x2F;&#x2F;计算高度，注意下行高为负数的情况</span><br><span class="line">CGFloat runHeight &#x3D; runAscent + fabs(runDescent);</span><br><span class="line">runBounds.size.height &#x3D; runHeight;</span><br></pre></td></tr></table></figure>

<p>####CTRunDelegate</p>
<p>CTRunDelegate用于图文混排时候的图片绘制，因为CoreText本身并不能进行图文混排，但是可以使用CTRunDelegate在需要显示图片的地方添加占位符，当CoreText绘制到该位置的时候，会触发CTRunDelegate代理，在代理方法中可以获取到该区域的大小以及图片信息，然后调用 <code>CGContextDrawImage(c, runBounds, image.CGImage)</code> 绘制图片即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *imgInfoDic &#x3D; @&#123;kCJImage:image,&#x2F;&#x2F;需要绘制的图片</span><br><span class="line">                             kCJImageWidth:@(size.width),&#x2F;&#x2F;需要绘制的图片区域宽度</span><br><span class="line">                             kCJImageHeight:@(size.height),&#x2F;&#x2F;需要绘制的图片区域高度&#125;;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;创建CTRunDelegateRef并设置回调函数</span><br><span class="line">CTRunDelegateCallbacks imageCallbacks;</span><br><span class="line">imageCallbacks.version &#x3D; kCTRunDelegateVersion1;</span><br><span class="line">imageCallbacks.dealloc &#x3D; RunDelegateDeallocCallback;</span><br><span class="line">imageCallbacks.getWidth &#x3D; RunDelegateGetWidthCallback;&#x2F;&#x2F;图片区域宽度回调</span><br><span class="line">imageCallbacks.getAscent &#x3D; RunDelegateGetAscentCallback;&#x2F;&#x2F;图片区域上行高回调</span><br><span class="line">imageCallbacks.getDescent &#x3D; RunDelegateGetDescentCallback;&#x2F;&#x2F;图片区域下行高回调</span><br><span class="line">CTRunDelegateRef runDelegate &#x3D; CTRunDelegateCreate(&amp;imageCallbacks, (__bridge void *)imgInfoDic);</span><br><span class="line">&#x2F;&#x2F;初始化空白占位字符</span><br><span class="line">unichar imgReplacementChar &#x3D; 0xFFFC;</span><br><span class="line">NSString *imgReplacementString &#x3D; [NSString stringWithCharacters:&amp;imgReplacementChar length:1];</span><br><span class="line">&#x2F;&#x2F;插入图片 空白占位符</span><br><span class="line">NSMutableString *imgPlaceholderStr &#x3D; [[NSMutableString alloc]initWithCapacity:3];</span><br><span class="line">[imgPlaceholderStr appendString:imgReplacementString];</span><br><span class="line">NSRange imgRange &#x3D; NSMakeRange(0, imgPlaceholderStr.length);</span><br><span class="line">NSMutableAttributedString *imageAttributedString &#x3D; [[NSMutableAttributedString alloc] initWithString:imgPlaceholderStr];</span><br><span class="line">&#x2F;&#x2F;将CTRunDelegate记录到NSMutableAttributedString的富文本信息中</span><br><span class="line">[imageAttributedString addAttribute:(NSString *)kCTRunDelegateAttributeName value:(__bridge id)runDelegate range:imgRange];</span><br><span class="line">&#x2F;&#x2F;kCJImageAttributeName为自定义的记录图片信息的富文本属性</span><br><span class="line">[imageAttributedString addAttribute:kCJImageAttributeName value:imgInfoDic range:imgRange];</span><br></pre></td></tr></table></figure>



<p>看完上面的概念介绍，相信你已经对iOS的图文绘制原理有了基础的认识，以上各个类的关联关系如图所示：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E8%AF%B4%E6%98%8E.png" alt="CoreText说明">完整的绘制流程如下：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="绘制流程"></p>
<p>###自定义图文混排控件</p>
<p>自定义图文混排控件，可以基于UILabel来实现，UILabel本身已支持NSAttributedString富文本展示，我们只需在原有基础上扩展指定字符区域背景色、插入图片（或自定义view）展示、指定锚点点击响应事件、点击时候的字符高亮展示等功能即可。</p>
<h4 id="绘制关键点说明"><a href="#绘制关键点说明" class="headerlink" title="绘制关键点说明"></a>绘制关键点说明</h4><p>首先在设置NSAttributedString富文本属性的时候，增加自定义属性。NSAttributedString的富文本属性Attributes其实就是字典，那么可以在其中添加自定义的key-value配置，类似以下说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 删除线宽度。值为NSNumber。默认 &#96;0.0f&#96;，表示无删除线</span><br><span class="line"> *&#x2F;</span><br><span class="line">extern NSString * const kCJStrikethroughStyleAttributeName;</span><br><span class="line">&#x2F;**</span><br><span class="line"> 删除线颜色。值为UIColor。默认 &#96;[UIColor blackColor]&#96;。</span><br><span class="line"> *&#x2F;</span><br><span class="line">extern NSString * const kCJStrikethroughColorAttributeName;</span><br><span class="line">&#x2F;**</span><br><span class="line"> 对NSAttributedString文本设置锚点属性时候的唯一标识</span><br><span class="line"> *&#x2F;</span><br><span class="line">extern NSString * const kCJLinkStringIdentifierAttributesName;</span><br></pre></td></tr></table></figure>

<p>第二步就是在遍历获取CTRun时，将属于锚点的CTRun的<code>frame</code>区域信息记录起来，同时还要记录该锚点对应的扩展参数，以及合并具有相同属性的CTRun。</p>
<p>第三步是绘制字符，如果包含自定义属性，那么需要调用CoreGraphics的相关方法进行扩展属性的设置，比如先填充背景色<code>CGContextSetFillColorWithColor(c,color);</code> 再绘制文字<code>CTRunDraw(runRef, c, CFRangeMake(0, 0));</code>  再添加边框线、删除线<code>CGContextSetStrokeColorWithColor(c,color);</code> 你可以把这个过程想象是成在一张画布上绘画，绘制时候需要注意不同图层的层级关系，不然上面的图层会将下面的图层覆盖。</p>
<p>最后一步是图片展示，如果CTRun是包含CTRunDelegate的显示区域，那么系统会将你设置好大小的区域空白出来，你只需在该位置上画出图片即可：<code>CGContextDrawImage(c, runBounds, image.CGImage);</code>另外我还在此基础上做了扩展，不单单支持图文混排，还可以在指定区域上插入任意UIView。原理是同样借助CTRunDelegate在对应位置上预留出指定大小的空白区域，然后将需要插入的UIView存储在NSAttributedString的Attributes属性中，当绘制到该位置时只需调用<code>[self addSubview:view];</code>即可。</p>
<p>####点击响应</p>
<p>UILabel继承自UIView和UIResponder，那么可以基于iOS的事件响应链机制来实现锚点点击事件。</p>
<p>重写<code>hitTest: withEvent:</code>方法，在其中判断是否需要响应点击事件，否则将响应事件向下传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    &#x2F;&#x2F; ![self linkAtPoint:point extendsLinkTouchArea:NO]表示不在锚点点击范围内</span><br><span class="line">    if (![self linkAtPoint:point extendsLinkTouchArea:NO] || !self.userInteractionEnabled || self.hidden || self.alpha &lt; 0.01) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果支持选择复制</span><br><span class="line">        if (self.enableCopy) &#123;</span><br><span class="line">            return [super hitTest:point withEvent:event];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于如何判断是否在锚点点击范围内，可参照<code>linkAtPoint: extendsLinkTouchArea:</code>伪函数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (CJGlyphRunStrokeItem *)linkAtPoint:(CGPoint)point extendsLinkTouchArea:(BOOL)extendsLinkTouchArea &#123;</span><br><span class="line">    &#x2F;&#x2F; CJGlyphRunStrokeItem 对应 CTRun，其中记录了字符区域（bounds）的大小</span><br><span class="line">    CJGlyphRunStrokeItem *resultItem &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F; _linkStrokeItemArray 表示记录了所有锚点信息的数组</span><br><span class="line">    for (CJGlyphRunStrokeItem *item in _linkStrokeItemArray) &#123;</span><br><span class="line">        if (CGRectContainsPoint(item.bounds, point)) &#123;</span><br><span class="line">            resultItem &#x3D; item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return resultItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写touches系列方法，首先在<code>touchesBegan: withEvent:</code>中判断是否点击了锚点区域，如果是则触发重绘以达到点击高亮效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    UITouch *touch &#x3D; [touches anyObject];</span><br><span class="line">    CJGlyphRunStrokeItem *item &#x3D; [self linkAtPoint:[touch locationInView:self] extendsLinkTouchArea:self.extendsLinkTouchArea];</span><br><span class="line">    &#x2F;&#x2F;点击锚点存在</span><br><span class="line">    if (item) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO: 触发重绘操作，达到点击锚点高亮效果</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        [super touchesBegan:touches withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>touchesEnded: withEvent:</code>中处理点击事件的响应操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    &#x2F;&#x2F;  如果是长按点击，交由长按点击手势UILongPressGestureRecognizer响应</span><br><span class="line">    if (_longPress) &#123;</span><br><span class="line">        [super touchesEnded:touches withEvent:event];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (_currentClickRunStrokeItem) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前是点击锚点事件，抛出点击回调事件</span><br><span class="line">            if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(CJLable:didClickLink:)]) &#123;</span><br><span class="line">                [self.delegate CJLable:self didClickLink:linkModel];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; TODO: 再次重绘，还原点击前的文本显示</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [super touchesEnded:touches withEvent:event];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意一下，如果是双击点击事件或者长按点击事件，那么在touches系列的回调方法中是不能处理的，交互处理应该放到<code>UITapGestureRecognizer</code>和<code>UILongPressGestureRecognizer</code>的响应方法中判断。另外手势事件的响应方法中是无法得到当前点击位置的点坐标<code>CGPoint</code>的，这里用到了比较取巧的方式（通过Rumtime关联属性）达到了判断点击响应的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在此时刚接收到手势事件的回调中，将UITouch关联到 UIGestureRecognizer实例</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch &#123;</span><br><span class="line">    if (gestureRecognizer &#x3D;&#x3D; self.longPressGestureRecognizer) &#123;</span><br><span class="line">        objc_setAssociatedObject(self.longPressGestureRecognizer, &amp;kAssociatedUITouchKey, touch, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (gestureRecognizer &#x3D;&#x3D; self.doubleTapGes) &#123;</span><br><span class="line">        objc_setAssociatedObject(self.doubleTapGes, &amp;kAssociatedUITouchKey, touch, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 双击点击事件</span><br><span class="line">- (void)tapTwoAct:(UITapGestureRecognizer *)sender &#123;</span><br><span class="line">    &#x2F;&#x2F; Runtime属性关联，获取到对应的UITouch，并计算得到点击坐标：[touch locationInView:self]</span><br><span class="line">    UITouch *touch &#x3D; objc_getAssociatedObject(self.doubleTapGes, &amp;kAssociatedUITouchKey);</span><br><span class="line">    CJGlyphRunStrokeItem *item &#x3D; [self linkAtPoint:[touch locationInView:self] extendsLinkTouchArea:self.extendsLinkTouchArea];</span><br><span class="line">    if (item) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO: 如果当前是双击点击锚点事件，抛出点击回调事件</span><br><span class="line">        if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(CJLable:didClickLink:)]) &#123;</span><br><span class="line">            [self.delegate CJLable:self didClickLink:linkModel];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; TODO: 再次重绘，还原点击前的文本显示</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果不是点击锚点且开启了选择复制功能</span><br><span class="line">    else &#123;</span><br><span class="line">        if (self.enableCopy) &#123;</span><br><span class="line">            &#x2F;&#x2F;TODO: 显示选择复制提示视图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 长按点击事件</span><br><span class="line">- (void)longPressGestureDidFire:(UILongPressGestureRecognizer *)sender &#123;</span><br><span class="line">    &#x2F;&#x2F; Runtime属性关联，获取到对应的UITouch，并计算得到点击坐标：[touch locationInView:self]</span><br><span class="line">    UITouch *touch &#x3D; objc_getAssociatedObject(self.longPressGestureRecognizer, &amp;kAssociatedUITouchKey);</span><br><span class="line">    CGPoint point &#x3D; [touch locationInView:self];</span><br><span class="line">    BOOL isLinkItem &#x3D; [self containslinkAtPoint:[touch locationInView:self]];</span><br><span class="line">    switch (sender.state) &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO: 如果当前是长按锚点事件，抛出长按回调事件</span><br><span class="line">        case UIGestureRecognizerStateBegan: &#123;</span><br><span class="line">            if (isLinkItem) &#123;</span><br><span class="line">                if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(CJLable:didLongPressLink:)]) &#123;</span><br><span class="line">                        [self.delegate CJLable:self didLongPressLink:linkModel];</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果不是点击锚点且开启了选择复制功能</span><br><span class="line">    		else &#123;</span><br><span class="line">        		if (self.enableCopy) &#123;</span><br><span class="line">            		&#x2F;&#x2F;TODO: 长按显示放大镜</span><br><span class="line">                &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case UIGestureRecognizerStateEnded:&#123;</span><br><span class="line">            &#x2F;&#x2F;TODO: 再次重绘，还原长按前的文本显示</span><br><span class="line">            &#x2F;&#x2F;如果支持复制</span><br><span class="line">            if (self.enableCopy) &#123;</span><br><span class="line">                &#x2F;&#x2F;TODO: 显示选择复制提示视图</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case UIGestureRecognizerStateChanged:</span><br><span class="line">    		&#x2F;&#x2F;如果支持复制</span><br><span class="line">            if (self.enableCopy) &#123;</span><br><span class="line">                &#x2F;&#x2F;TODO: 更新放大镜位置，以及更新选择复制区域</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看一下自定义点击控件的效果图</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94.gif" alt="点击响应"></p>
<h4 id="选择、复制"><a href="#选择、复制" class="headerlink" title="选择、复制"></a>选择、复制</h4><p>自定义图文混排控件还可以支持选择复制功能，当然这里说的选择复制不是指点击唤起<code>UIMenuController</code>菜单，然后出现复制剪切选项，点击则只能复制所有文本。那样的例子网上已经有很多，没有必要在这里再大费周章地罗列说明。 其需要具备的是类似于UITextView或UIWebView那样双击或长按，可出现<code>拷贝、选择、全选</code>选项，同时选中字符左右出现指示大头针，拖动则有放大镜提示当前选中的字符，并且要尽量做到与系统行为一致。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6.gif" alt="选择复制"></p>
<p>需求细化后选择复制的要点主要包含以下：</p>
<ul>
<li>选中字符后出现<code>拷贝、选择 全选 </code>菜单，这个使用系统的<code>UIMenuController</code>功能即可实现，不存在难点问题。</li>
<li>对于选中的文字，起始要有大头针标识，中间填充浅蓝色背景，而且这一部分区域会是一块不规则多边形。系统没有提供现成可复用的对应UI控件，但只要我们能够判断到选中区域，就能在左右画上大头针，中间填充颜色，所以这一块也不存在问题。</li>
<li>拖动选择的过程中，出现放大镜来提示选中字符的更改。在能够准确获取到当前触摸点坐标的前提下，只需要将触摸点周围区域的图层截取并作<code>CGContextScaleCTM</code>缩放，然后再将放大后的图层显示出来即可，所以这个也是可以实现的。</li>
<li>最后便是重点了，如何判断每一个字符对应的<code>frame</code>坐标位置，并要求在手指移动时能够准确判断选择区域的变化。</li>
</ul>
<p>前面已经讲到，单行文本中具有相同富文本属性的字符会被绘制到同一个<code>CTRun</code>中，而通过<code>CTRun</code>可以计算得到它的<code>frame</code>大小。那么重点则变成如何使得每一个字符（图片或插入UIView）对应一个<code>CTRun</code>。</p>
<p>解决很简单：只要保证NSAttributedString中每一个字符的Attributes属性不一样就可以了。我开始的做法是添加一个自定义属性<code>kCJIndexAttributesName</code>，然后给每个字符存储不同的index值，并且在全部图文遍历绘制过一次后将<code>kCJIndexAttributesName</code>移除，这样在后续的重绘中就会减少<code>CTRun</code>的拆分数量，提高了效率。</p>
<p>然而，理想很美好，现实很打击。就算自定义属性<code>kCJIndexAttributesName</code>移除了，可<code>CTRun</code>还是会被拆分为单个字符，但是如果使用系统自带的属性则不会如此。无奈只能从系统方法中寻找解决思路，幸好发现了<code>NSLinkAttributeName</code>属性，这是UITextView中用来设置http链接的扩展属性，存储的对象是<code>NSURL</code>或<code>NSString</code>类型，而UILabel默认是不支持http链点的，使用<code>NSLinkAttributeName</code>属性可以最大限度的降低UILabel对默认NSAttributedString展示的影响。同时为了更好的判断计算，我将存储的对象改为NSURL的子类<code>CJCTRunUrl</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;给每一个字符设置index值，enableCopy&#x3D;YES时生效</span><br><span class="line">__block NSInteger index &#x3D; 0;</span><br><span class="line">[attText.string enumerateSubstringsInRange:NSMakeRange(0, [attText length]) options:NSStringEnumerationByComposedCharacterSequences usingBlock:</span><br><span class="line"> ^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) &#123;</span><br><span class="line">     CJCTRunUrl *runUrl &#x3D; nil;</span><br><span class="line">     if (!runUrl) &#123;</span><br><span class="line">         NSString *urlStr &#x3D; [NSString stringWithFormat:@&quot;https:&#x2F;&#x2F;www.CJLabel%@&quot;,@(index)];</span><br><span class="line">         runUrl &#x3D; [CJCTRunUrl URLWithString:urlStr];</span><br><span class="line">     &#125;</span><br><span class="line">     runUrl.index &#x3D; index;</span><br><span class="line">     runUrl.rangeValue &#x3D; [NSValue valueWithRange:substringRange];</span><br><span class="line">     [attText addAttribute:NSLinkAttributeName</span><br><span class="line">                     value:runUrl</span><br><span class="line">                     range:substringRange];</span><br><span class="line">     index++;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>

<p>选择复制视图展示的交互逻辑则在双击或长按手势中实现，前面 <strong>点击响应</strong> 的伪代码示意中已经说明。另外讲解一下选择复制视图的实现细节：</p>
<p>其中的<code>拷贝、选择、全选</code>菜单使用系统提供的<code>UIMenuController</code>实现，在双击或长按时只要将它显示到手指点击对应的位置上就行。</p>
<p>放大镜则是自定义UIView，并在上面添加一个<code>CALayer</code>，再在<code>CALayer</code>上根据更新的点坐标做放大效果，<code>CALayer</code>的放大境处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawInContext:(CGContextRef)ctx &#123;</span><br><span class="line">	CGContextTranslateCTM(ctx, self.frame.size.width&#x2F;2, self.frame.size.height&#x2F;2);</span><br><span class="line">	CGContextScaleCTM(ctx, 1.40, 1.40);</span><br><span class="line">	&#x2F;&#x2F;self.pointToMagnify是更新的放大点坐标</span><br><span class="line">	CGContextTranslateCTM(ctx, -1 * self.pointToMagnify.x, -1 * self.pointToMagnify.y);</span><br><span class="line">	[CJkeyWindow().layer renderInContext:ctx];</span><br><span class="line">	CJkeyWindow().layer.contents &#x3D; (id)nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大头针包含的提示用户选中区域，同样由自定义UIView实现，在自定义view上面填充颜色以及在起始结束位置画出大头针，其中的填充颜色区域包含三部分<code>headRect</code> <code>middleRect</code> <code>tailRect</code></p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F.png" alt="选择区域"></p>
<p>这三部分存在任意组合的情况，填充颜色的时候要对这三部分区分开来分别进行填充。因为有可能存在只有<code>headRect</code> <code>middleRect</code> 或只有<code>middleRect</code> <code>tailRect</code>，又或者只有 <code>middleRect</code> 的情况，而且填充颜色使用的是<code>CoreGraphics</code>中的绘图API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">&#x2F;&#x2F;填充的背景色</span><br><span class="line">UIColor *backColor &#x3D; CJUIRGBColor(0,84,166,0.2);</span><br><span class="line">[backColor set];</span><br><span class="line">CGContextAddRect(ctx, self.headRect);</span><br><span class="line">CGContextStrokePath(ctx);</span><br></pre></td></tr></table></figure>

<p>接下来便是如何显示这三个选择复制相关的视图了，一开始我只是简单的将它们添加到<code>Label</code>上面来统一管理，但这样会存在一个问题。那就是当页面中存在多个<code>Label</code>，并且对每个<code>Label</code>分别执行选择复制操作时，那么不同的<code>label</code>上都会出现选择复制视图，这是与系统的默认行为是不一致的。权衡之后将以上三个视图的显示作为单例处理，全局只初始化一次，避免了重复初始化的开销。并且将它添加到<code>UIWindow</code>层，这样在不同的<code>Label</code>之间进行选择复制时，也只会显示一个选择复制视图。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>以上便是iOS图文绘制原理以及自定义图文控件的说明，关键点是充分理解你看到的每一个字符在底层绘制显示的时候与<code>CTFrame</code> <code>CTLine</code> <code>CTRun</code>等实体类的对应关系，并借助其计算得到每一个字符的区域<code>frame</code>信息，有了区域<code>frame</code>信息便能够扩展实现各种自定义功能（点击响应、插入图片、选择拷贝等）。</p>
<p>全文完，更多的实现可以查看源码<a target="_blank" rel="noopener" href="https://github.com/lele8446/CJLabel">CJLabel</a>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/26/iOS%E7%AD%BE%E5%90%8D%E6%89%93%E5%8C%85%EF%BC%8C%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E5%90%97/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/15/hello-world/" rel="prev" title="Hello World">
                Hello World <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFramesetter"><span class="nav-number">1.</span> <span class="nav-text">CTFramesetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFrame"><span class="nav-number">2.</span> <span class="nav-text">CTFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTRun"><span class="nav-number">3.</span> <span class="nav-text">CTRun</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">4.</span> <span class="nav-text">绘制关键点说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E3%80%81%E5%A4%8D%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">选择、复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-number"></span> <span class="nav-text">写在最后</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lele8446</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
