<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Runtime,CoreText," />










<meta name="description" content="本文初次发表于InfoQ  深入理解 iOS 图文混排原理并自定义图文控件  iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助NSAttributedString来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILab">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解图文混排原理并自定义图文控件">
<meta property="og:url" content="http://example.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/index.html">
<meta property="og:site_name" content="C.J.Lian">
<meta property="og:description" content="本文初次发表于InfoQ  深入理解 iOS 图文混排原理并自定义图文控件  iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助NSAttributedString来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILab">
<meta property="og:locale">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E5%9D%90%E6%A0%87.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E8%A1%8C%E9%AB%98.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CTRun%E8%AF%B4%E6%98%8E.jpg">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E8%AF%B4%E6%98%8E.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94.gif">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6.gif">
<meta property="og:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F.png">
<meta property="article:published_time" content="2019-10-24T03:50:03.000Z">
<meta property="article:modified_time" content="2019-10-25T04:15:00.000Z">
<meta property="article:author" content="lele8446">
<meta property="article:tag" content="Runtime">
<meta property="article:tag" content="CoreText">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/深入理解图文混排原理并自定义图文控件/"/>





  <title>深入理解图文混排原理并自定义图文控件 | C.J.Lian</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">C.J.Lian</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">lele8446技术加油站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E5%8E%9F%E7%90%86%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%8E%A7%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="C.J.Lian">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解图文混排原理并自定义图文控件</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-24T11:50:03+08:00">
                2019-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文初次发表于<a target="_blank" rel="noopener" href="https://www.infoq.cn/"><strong>InfoQ</strong> </a> <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/cy916KUJYK7GA3p2VjZH">深入理解 iOS 图文混排原理并自定义图文控件</a></p>
</blockquote>
<p>iOS开发中一般用UILabel来展示文字、UIImageView用来显示图片、UIButton用于简单的图文点击响应事件，稍复杂一点的可以借助<code>NSAttributedString</code>来实现图文混排需求，又或者将图文内容转换为HTML由WKWebView（UIWebView）来展示。然而以上方案都有各自的局限性：UILabel绘制NSAttributedString不能灵活定位文本内的点击锚点区域，转换为HTML展示则带来Native与Web端交互成本以及WKWebView自身的性能问题。</p>
<p>那么，是否能有一种控件，在满足富文本图文混排的同时还能响应自定义锚点点击事件？要实现以上需求，我们首先从iOS图文展示原理说起。</p>
<span id="more"></span>

<h3 id="图文绘制架构"><a href="#图文绘制架构" class="headerlink" title="图文绘制架构"></a>图文绘制架构</h3><p>iOS7之后的图文绘制架构如下图所示，越往上封装程度越高，但可定制程度也越低，本文涉及讲解的主要是<code>CoreText</code>以及<code>CoreGraphics</code>层级 。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E6%9E%B6%E6%9E%84.png" alt="CoreText架构"></p>
<h3 id="CoreGraphics"><a href="#CoreGraphics" class="headerlink" title="CoreGraphics"></a>CoreGraphics</h3><p>从下往上说，首先是<strong>CoreGraphics</strong>。这是一个C语言接口的核心图形库，而且它是跨平台的类库，iOS和macOS系统均可使用。虽然它很偏底层，但很多情况下其实你已经使用过它了：比如<strong>CGAffineTransform</strong>用于形变，<strong>CGBitmapContext</strong>用于截图或者图片绘制，<strong>CGContext</strong>用于获取上下文进行直线、曲线、不规则图形绘制等。</p>
<p>这里着重说明下<strong>CGContext</strong>上下文。上下文类似于进行绘画时候的画布，使用<code>UIGraphicsGetCurrentContext()</code>可以快捷得到当前上下文，同时需要注意在CoreText下坐标系的原点为视图的左下角，x轴向右为正方向，y轴向上为正方向。而UIKit坐标系的原点是视图的左上角，x轴向右为正方向，y轴向下为正方向，所以我们在进行图文绘制前需要进行坐标反转，如图所示：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E5%9D%90%E6%A0%87.png" alt="CoreText坐标"></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//获取上下文</span><br><span class="hljs-built_in">CGContextRef</span> c = <span class="hljs-built_in">UIGraphicsGetCurrentContext</span>();<br><span class="hljs-comment">// 将当前图形状态推入堆栈</span><br><span class="hljs-built_in">CGContextSaveGState</span>(c);<br><span class="hljs-comment">// 设置字形变换矩阵为CGAffineTransformIdentity，也就是说每一个字形都不做图形变换</span><br><span class="hljs-built_in">CGContextSetTextMatrix</span>(c, <span class="hljs-built_in">CGAffineTransformIdentity</span>);<br><span class="hljs-comment">// 坐标转换，UIKit 坐标原点在左上角，CoreText 坐标原点在左下角</span><br><span class="hljs-built_in">CGContextTranslateCTM</span>(c, <span class="hljs-number">0.0</span>f, insetRect.size.height);<br><span class="hljs-built_in">CGContextScaleCTM</span>(c, <span class="hljs-number">1.0</span>f, <span class="hljs-number">-1.0</span>f);<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span>进行图文绘制操作</span><br><span class="hljs-comment">//...</span><br><span class="hljs-comment">// 绘制完成，将堆栈顶部的状态弹出，返回到之前的图形状态</span><br><span class="hljs-built_in">CGContextRestoreGState</span>(c);<br></code></pre></td></tr></table></figure>

<p>以上使用CoreGraphics进行图文绘制的过程，可以在<code>drawRect:</code>或 <code>drawTextInRect:</code>等相关方法中进行操作。</p>
<h3 id="CoreText框架"><a href="#CoreText框架" class="headerlink" title="CoreText框架"></a>CoreText框架</h3><p><strong>CoreText</strong>是iOS中用于文本绘制的引擎，其位于<code>UIKit</code>中和<code>CoreGraphics/Quartz</code>之间。查看开发文档，可以看到CoreText架构主要包含以下类，其中标红部分是图文绘制需要使用到的相关类，我们逐个介绍。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText.png" alt="CoreText"></p>
<h4 id="CTFramesetter"><a href="#CTFramesetter" class="headerlink" title="CTFramesetter"></a>CTFramesetter</h4><p>CTFramesetter是管理生成CTFrame的工厂类，其中记录了需要绘制的文本内容中不同字符串对应的富文本属性（加粗、颜色、字号等），通过NSAttributedString可生成CTFrameSetter。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="hljs-built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];<br><span class="hljs-comment">//生成CTFramesetter</span><br><span class="hljs-built_in">CTFramesetterRef</span> framesetter = <span class="hljs-built_in">CTFramesetterCreateWithAttributedString</span>((<span class="hljs-built_in">CFAttributedStringRef</span>)attributedStr);<br><span class="hljs-built_in">CFRelease</span>(framesetter);<br></code></pre></td></tr></table></figure>

<h4 id="CTFrame"><a href="#CTFrame" class="headerlink" title="CTFrame"></a>CTFrame</h4><p>CTFrame描述了总的文本绘制区域的<code>frame</code>，通过它你可以得到在指定区域内绘制的文本一共有多少行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CGRect</span> rect = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><span class="hljs-comment">//生成绘制区域路径</span><br><span class="hljs-built_in">CGMutablePathRef</span> path = <span class="hljs-built_in">CGPathCreateMutable</span>();<br><span class="hljs-built_in">CGPathAddRect</span>(path, <span class="hljs-literal">NULL</span>, rect);<br><span class="hljs-comment">//生成CTFrame</span><br><span class="hljs-built_in">CTFrameRef</span> frame = <span class="hljs-built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="hljs-built_in">CFRangeMake</span>(<span class="hljs-number">0</span>, [attributedStr length]), path, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">//获取一共有多少行</span><br><span class="hljs-built_in">CFArrayRef</span> lines = <span class="hljs-built_in">CTFrameGetLines</span>(frame);<br><br><span class="hljs-built_in">CFRelease</span>(frame);<br><span class="hljs-built_in">CGPathRelease</span>(path);<br></code></pre></td></tr></table></figure>

<h4 id="CTLine"><a href="#CTLine" class="headerlink" title="CTLine"></a>CTLine</h4><p>CTLine记录了需要绘制的单行文本信息，通过它你可以得到当前行的上行高、下行高以及行间距等信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//获取第一行信息</span><br><span class="hljs-built_in">CTLineRef</span> line = <span class="hljs-built_in">CFArrayGetValueAtIndex</span>(lines, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//上行高、下行高、行间距</span><br><span class="hljs-built_in">CGFloat</span> lineAscent = <span class="hljs-number">0.0</span>f, lineDescent = <span class="hljs-number">0.0</span>f, lineLeading = <span class="hljs-number">0.0</span>f;<br><span class="hljs-comment">//获取行宽、行高信息</span><br><span class="hljs-built_in">CGFloat</span> lineWidth = <span class="hljs-built_in">CTLineGetTypographicBounds</span>(line, &amp;lineAscent, &amp;lineDescent, &amp;lineLeading);<br></code></pre></td></tr></table></figure>

<p>关于行文本的上下行高、行间距、原点、基线等的说明，可参照下图：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E8%A1%8C%E9%AB%98.png" alt="行高"></p>
<p>系统绘制文本的时候，首先会以基线（Baseline）为基准，从当前行的基线最左侧的原点（Origin）开始，计算得到上行高（Ascent），下行高（Descent），不同行之间的行间距（Leading），以及行宽信息。</p>
<h4 id="CTRun"><a href="#CTRun" class="headerlink" title="CTRun"></a>CTRun</h4><p>CTRun描述了单行文本中具有相同富文本属性的字符实体，每一行文字中可能有多个CTRun，也有可能只包含一个CTRun。如下图，这行文字中包含三个CTRun，分别为：<code>这是</code>     <code>一段</code>  <code>测试数据</code></p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CTRun%E8%AF%B4%E6%98%8E.jpg" alt="CTRun说明"></p>
<p>与CTLine一样，同样可以计算得到单个CTRun的绘制区域大小。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//初始化CTRun的区域大小为CGRectZero</span><br><span class="hljs-built_in">CGRect</span> runBounds = <span class="hljs-built_in">CGRectZero</span>;<br><span class="hljs-comment">//初始化CTRun的上行高、下行高、行间距</span><br><span class="hljs-built_in">CGFloat</span> runAscent = <span class="hljs-number">0.0</span>f, runDescent = <span class="hljs-number">0.0</span>f, runLeading = <span class="hljs-number">0.0</span>f;<br><span class="hljs-comment">//计算得到上下行高、行间距以及CTRun绘制区域宽度</span><br>runBounds.size.width = (<span class="hljs-built_in">CGFloat</span>)<span class="hljs-built_in">CTRunGetTypographicBounds</span>(glyphRun, <span class="hljs-built_in">CFRangeMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), &amp;runAscent, &amp;runDescent, &amp;runLeading);<br><span class="hljs-comment">//计算高度，注意下行高为负数的情况</span><br><span class="hljs-built_in">CGFloat</span> runHeight = runAscent + fabs(runDescent);<br>runBounds.size.height = runHeight;<br></code></pre></td></tr></table></figure>

<h4 id="CTRunDelegate"><a href="#CTRunDelegate" class="headerlink" title="CTRunDelegate"></a>CTRunDelegate</h4><p>CTRunDelegate用于图文混排时候的图片绘制，因为CoreText本身并不能进行图文混排，但是可以使用CTRunDelegate在需要显示图片的地方添加占位符，当CoreText绘制到该位置的时候，会触发CTRunDelegate代理，在代理方法中可以获取到该区域的大小以及图片信息，然后调用 <code>CGContextDrawImage(c, runBounds, image.CGImage)</code> 绘制图片即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSDictionary</span> *imgInfoDic = @&#123;kCJImage:image,<span class="hljs-comment">//需要绘制的图片</span><br>                             kCJImageWidth:@(size.width),<span class="hljs-comment">//需要绘制的图片区域宽度</span><br>                             kCJImageHeight:@(size.height),<span class="hljs-comment">//需要绘制的图片区域高度&#125;;</span><br>    <br><span class="hljs-comment">//创建CTRunDelegateRef并设置回调函数</span><br><span class="hljs-built_in">CTRunDelegateCallbacks</span> imageCallbacks;<br>imageCallbacks.version = kCTRunDelegateVersion1;<br>imageCallbacks.dealloc = RunDelegateDeallocCallback;<br>imageCallbacks.getWidth = RunDelegateGetWidthCallback;<span class="hljs-comment">//图片区域宽度回调</span><br>imageCallbacks.getAscent = RunDelegateGetAscentCallback;<span class="hljs-comment">//图片区域上行高回调</span><br>imageCallbacks.getDescent = RunDelegateGetDescentCallback;<span class="hljs-comment">//图片区域下行高回调</span><br><span class="hljs-built_in">CTRunDelegateRef</span> runDelegate = <span class="hljs-built_in">CTRunDelegateCreate</span>(&amp;imageCallbacks, (__bridge <span class="hljs-keyword">void</span> *)imgInfoDic);<br><span class="hljs-comment">//初始化空白占位字符</span><br><span class="hljs-keyword">unichar</span> imgReplacementChar = <span class="hljs-number">0xFFFC</span>;<br><span class="hljs-built_in">NSString</span> *imgReplacementString = [<span class="hljs-built_in">NSString</span> stringWithCharacters:&amp;imgReplacementChar length:<span class="hljs-number">1</span>];<br><span class="hljs-comment">//插入图片 空白占位符</span><br><span class="hljs-built_in">NSMutableString</span> *imgPlaceholderStr = [[<span class="hljs-built_in">NSMutableString</span> alloc]initWithCapacity:<span class="hljs-number">3</span>];<br>[imgPlaceholderStr appendString:imgReplacementString];<br><span class="hljs-built_in">NSRange</span> imgRange = <span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, imgPlaceholderStr.length);<br><span class="hljs-built_in">NSMutableAttributedString</span> *imageAttributedString = [[<span class="hljs-built_in">NSMutableAttributedString</span> alloc] initWithString:imgPlaceholderStr];<br><span class="hljs-comment">//将CTRunDelegate记录到NSMutableAttributedString的富文本信息中</span><br>[imageAttributedString addAttribute:(<span class="hljs-built_in">NSString</span> *)kCTRunDelegateAttributeName value:(__bridge <span class="hljs-keyword">id</span>)runDelegate range:imgRange];<br><span class="hljs-comment">//kCJImageAttributeName为自定义的记录图片信息的富文本属性</span><br>[imageAttributedString addAttribute:kCJImageAttributeName value:imgInfoDic range:imgRange];<br></code></pre></td></tr></table></figure>



<p>看完上面的概念介绍，相信你已经对iOS的图文绘制原理有了基础的认识，以上各个类的关联关系如图所示：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/CoreText%E8%AF%B4%E6%98%8E.png" alt="CoreText说明">完整的绘制流程如下：</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="绘制流程"></p>
<h3 id="自定义图文混排控件"><a href="#自定义图文混排控件" class="headerlink" title="自定义图文混排控件"></a>自定义图文混排控件</h3><p>自定义图文混排控件，可以基于UILabel来实现，UILabel本身已支持NSAttributedString富文本展示，我们只需在原有基础上扩展指定字符区域背景色、插入图片（或自定义view）展示、指定锚点点击响应事件、点击时候的字符高亮展示等功能即可。</p>
<h4 id="绘制关键点说明"><a href="#绘制关键点说明" class="headerlink" title="绘制关键点说明"></a>绘制关键点说明</h4><p>首先在设置NSAttributedString富文本属性的时候，增加自定义属性。NSAttributedString的富文本属性Attributes其实就是字典，那么可以在其中添加自定义的key-value配置，类似以下说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 删除线宽度。值为NSNumber。默认 `0.0f`，表示无删除线</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> kCJStrikethroughStyleAttributeName;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 删除线颜色。值为UIColor。默认 `[UIColor blackColor]`。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> kCJStrikethroughColorAttributeName;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 对NSAttributedString文本设置锚点属性时候的唯一标识</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> kCJLinkStringIdentifierAttributesName;<br></code></pre></td></tr></table></figure>

<p>第二步就是在遍历获取CTRun时，将属于锚点的CTRun的<code>frame</code>区域信息记录起来，同时还要记录该锚点对应的扩展参数，以及合并具有相同属性的CTRun。</p>
<p>第三步是绘制字符，如果包含自定义属性，那么需要调用CoreGraphics的相关方法进行扩展属性的设置，比如先填充背景色<code>CGContextSetFillColorWithColor(c,color);</code> 再绘制文字<code>CTRunDraw(runRef, c, CFRangeMake(0, 0));</code>  再添加边框线、删除线<code>CGContextSetStrokeColorWithColor(c,color);</code> 你可以把这个过程想象是成在一张画布上绘画，绘制时候需要注意不同图层的层级关系，不然上面的图层会将下面的图层覆盖。</p>
<p>最后一步是图片展示，如果CTRun是包含CTRunDelegate的显示区域，那么系统会将你设置好大小的区域空白出来，你只需在该位置上画出图片即可：<code>CGContextDrawImage(c, runBounds, image.CGImage);</code>另外我还在此基础上做了扩展，不单单支持图文混排，还可以在指定区域上插入任意UIView。原理是同样借助CTRunDelegate在对应位置上预留出指定大小的空白区域，然后将需要插入的UIView存储在NSAttributedString的Attributes属性中，当绘制到该位置时只需调用<code>[self addSubview:view];</code>即可。</p>
<h4 id="点击响应"><a href="#点击响应" class="headerlink" title="点击响应"></a>点击响应</h4><p>UILabel继承自UIView和UIResponder，那么可以基于iOS的事件响应链机制来实现锚点点击事件。</p>
<p>重写<code>hitTest: withEvent:</code>方法，在其中判断是否需要响应点击事件，否则将响应事件向下传递。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-built_in">UIView</span> *)hitTest:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    <span class="hljs-comment">// ![self linkAtPoint:point extendsLinkTouchArea:NO]表示不在锚点点击范围内</span><br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> linkAtPoint:point extendsLinkTouchArea:<span class="hljs-literal">NO</span>] || !<span class="hljs-keyword">self</span>.userInteractionEnabled || <span class="hljs-keyword">self</span>.hidden || <span class="hljs-keyword">self</span>.alpha &lt; <span class="hljs-number">0.01</span>) &#123;<br>        <span class="hljs-comment">//如果支持选择复制</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.enableCopy) &#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span> hitTest:point withEvent:event];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至于如何判断是否在锚点点击范围内，可参照<code>linkAtPoint: extendsLinkTouchArea:</code>伪函数说明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (CJGlyphRunStrokeItem *)linkAtPoint:(<span class="hljs-built_in">CGPoint</span>)point extendsLinkTouchArea:(<span class="hljs-built_in">BOOL</span>)extendsLinkTouchArea &#123;<br>    <span class="hljs-comment">// CJGlyphRunStrokeItem 对应 CTRun，其中记录了字符区域（bounds）的大小</span><br>    CJGlyphRunStrokeItem *resultItem = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// _linkStrokeItemArray 表示记录了所有锚点信息的数组</span><br>    <span class="hljs-keyword">for</span> (CJGlyphRunStrokeItem *item <span class="hljs-keyword">in</span> _linkStrokeItemArray) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CGRectContainsPoint</span>(item.bounds, point)) &#123;<br>            resultItem = item;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultItem;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重写touches系列方法，首先在<code>touchesBegan: withEvent:</code>中判断是否点击了锚点区域，如果是则触发重绘以达到点击高亮效果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span> *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    <span class="hljs-built_in">UITouch</span> *touch = [touches anyObject];<br>    CJGlyphRunStrokeItem *item = [<span class="hljs-keyword">self</span> linkAtPoint:[touch locationInView:<span class="hljs-keyword">self</span>] extendsLinkTouchArea:<span class="hljs-keyword">self</span>.extendsLinkTouchArea];<br>    <span class="hljs-comment">//点击锚点存在</span><br>    <span class="hljs-keyword">if</span> (item) &#123;<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 触发重绘操作，达到点击锚点高亮效果</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        [<span class="hljs-keyword">super</span> touchesBegan:touches withEvent:event];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在<code>touchesEnded: withEvent:</code>中处理点击事件的响应操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)touchesEnded:(<span class="hljs-built_in">NSSet</span> *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event &#123;<br>    <span class="hljs-comment">//  如果是长按点击，交由长按点击手势UILongPressGestureRecognizer响应</span><br>    <span class="hljs-keyword">if</span> (_longPress) &#123;<br>        [<span class="hljs-keyword">super</span> touchesEnded:touches withEvent:event];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span> (_currentClickRunStrokeItem) &#123;<br>            <span class="hljs-comment">// 如果当前是点击锚点事件，抛出点击回调事件</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(CJLable:didClickLink:)]) &#123;<br>                [<span class="hljs-keyword">self</span>.delegate CJLable:<span class="hljs-keyword">self</span> didClickLink:linkModel];<br>            &#125;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 再次重绘，还原点击前的文本显示</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            [<span class="hljs-keyword">super</span> touchesEnded:touches withEvent:event];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要注意一下，如果是双击点击事件或者长按点击事件，那么在touches系列的回调方法中是不能处理的，交互处理应该放到<code>UITapGestureRecognizer</code>和<code>UILongPressGestureRecognizer</code>的响应方法中判断。另外手势事件的响应方法中是无法得到当前点击位置的点坐标<code>CGPoint</code>的，这里用到了比较取巧的方式（通过Rumtime关联属性）达到了判断点击响应的效果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">// 在此时刚接收到手势事件的回调中，将UITouch关联到 UIGestureRecognizer实例</span><br>- (<span class="hljs-built_in">BOOL</span>)gestureRecognizer:(<span class="hljs-built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldReceiveTouch:(<span class="hljs-built_in">UITouch</span> *)touch &#123;<br>    <span class="hljs-keyword">if</span> (gestureRecognizer == <span class="hljs-keyword">self</span>.longPressGestureRecognizer) &#123;<br>        objc_setAssociatedObject(<span class="hljs-keyword">self</span>.longPressGestureRecognizer, &amp;kAssociatedUITouchKey, touch, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gestureRecognizer == <span class="hljs-keyword">self</span>.doubleTapGes) &#123;<br>        objc_setAssociatedObject(<span class="hljs-keyword">self</span>.doubleTapGes, &amp;kAssociatedUITouchKey, touch, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-comment">// 双击点击事件</span><br>- (<span class="hljs-keyword">void</span>)tapTwoAct:(<span class="hljs-built_in">UITapGestureRecognizer</span> *)sender &#123;<br>    <span class="hljs-comment">// Runtime属性关联，获取到对应的UITouch，并计算得到点击坐标：[touch locationInView:self]</span><br>    <span class="hljs-built_in">UITouch</span> *touch = objc_getAssociatedObject(<span class="hljs-keyword">self</span>.doubleTapGes, &amp;kAssociatedUITouchKey);<br>    CJGlyphRunStrokeItem *item = [<span class="hljs-keyword">self</span> linkAtPoint:[touch locationInView:<span class="hljs-keyword">self</span>] extendsLinkTouchArea:<span class="hljs-keyword">self</span>.extendsLinkTouchArea];<br>    <span class="hljs-keyword">if</span> (item) &#123;<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 如果当前是双击点击锚点事件，抛出点击回调事件</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(CJLable:didClickLink:)]) &#123;<br>            [<span class="hljs-keyword">self</span>.delegate CJLable:<span class="hljs-keyword">self</span> didClickLink:linkModel];<br>        &#125;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 再次重绘，还原点击前的文本显示</span><br>    &#125;<br>    <span class="hljs-comment">//如果不是点击锚点且开启了选择复制功能</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.enableCopy) &#123;<br>            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 显示选择复制提示视图</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 长按点击事件</span><br>- (<span class="hljs-keyword">void</span>)longPressGestureDidFire:(<span class="hljs-built_in">UILongPressGestureRecognizer</span> *)sender &#123;<br>    <span class="hljs-comment">// Runtime属性关联，获取到对应的UITouch，并计算得到点击坐标：[touch locationInView:self]</span><br>    <span class="hljs-built_in">UITouch</span> *touch = objc_getAssociatedObject(<span class="hljs-keyword">self</span>.longPressGestureRecognizer, &amp;kAssociatedUITouchKey);<br>    <span class="hljs-built_in">CGPoint</span> point = [touch locationInView:<span class="hljs-keyword">self</span>];<br>    <span class="hljs-built_in">BOOL</span> isLinkItem = [<span class="hljs-keyword">self</span> containslinkAtPoint:[touch locationInView:<span class="hljs-keyword">self</span>]];<br>    <span class="hljs-keyword">switch</span> (sender.state) &#123;<br>        <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 如果当前是长按锚点事件，抛出长按回调事件</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateBegan</span>: &#123;<br>            <span class="hljs-keyword">if</span> (isLinkItem) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.delegate &amp;&amp; [<span class="hljs-keyword">self</span>.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(CJLable:didLongPressLink:)]) &#123;<br>                        [<span class="hljs-keyword">self</span>.delegate CJLable:<span class="hljs-keyword">self</span> didLongPressLink:linkModel];<br>                    &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果不是点击锚点且开启了选择复制功能</span><br>    		<span class="hljs-keyword">else</span> &#123;<br>        		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.enableCopy) &#123;<br>            		<span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 长按显示放大镜</span><br>                &#125;<br>        	&#125;<br>    	&#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateEnded</span>:&#123;<br>            <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 再次重绘，还原长按前的文本显示</span><br>            <span class="hljs-comment">//如果支持复制</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.enableCopy) &#123;<br>                <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 显示选择复制提示视图</span><br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-built_in">UIGestureRecognizerStateChanged</span>:<br>    		<span class="hljs-comment">//如果支持复制</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.enableCopy) &#123;<br>                <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 更新放大镜位置，以及更新选择复制区域</span><br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>来看一下自定义点击控件的效果图</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94.gif" alt="点击响应"></p>
<h4 id="选择、复制"><a href="#选择、复制" class="headerlink" title="选择、复制"></a>选择、复制</h4><p>自定义图文混排控件还可以支持选择复制功能，当然这里说的选择复制不是指点击唤起<code>UIMenuController</code>菜单，然后出现复制剪切选项，点击则只能复制所有文本。那样的例子网上已经有很多，没有必要在这里再大费周章地罗列说明。 其需要具备的是类似于UITextView或UIWebView那样双击或长按，可出现<code>拷贝、选择、全选</code>选项，同时选中字符左右出现指示大头针，拖动则有放大镜提示当前选中的字符，并且要尽量做到与系统行为一致。</p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%A4%8D%E5%88%B6.gif" alt="选择复制"></p>
<p>需求细化后选择复制的要点主要包含以下：</p>
<ul>
<li>选中字符后出现<code>拷贝、选择 全选 </code>菜单，这个使用系统的<code>UIMenuController</code>功能即可实现，不存在难点问题。</li>
<li>对于选中的文字，起始要有大头针标识，中间填充浅蓝色背景，而且这一部分区域会是一块不规则多边形。系统没有提供现成可复用的对应UI控件，但只要我们能够判断到选中区域，就能在左右画上大头针，中间填充颜色，所以这一块也不存在问题。</li>
<li>拖动选择的过程中，出现放大镜来提示选中字符的更改。在能够准确获取到当前触摸点坐标的前提下，只需要将触摸点周围区域的图层截取并作<code>CGContextScaleCTM</code>缩放，然后再将放大后的图层显示出来即可，所以这个也是可以实现的。</li>
<li>最后便是重点了，如何判断每一个字符对应的<code>frame</code>坐标位置，并要求在手指移动时能够准确判断选择区域的变化。</li>
</ul>
<p>前面已经讲到，单行文本中具有相同富文本属性的字符会被绘制到同一个<code>CTRun</code>中，而通过<code>CTRun</code>可以计算得到它的<code>frame</code>大小。那么重点则变成如何使得每一个字符（图片或插入UIView）对应一个<code>CTRun</code>。</p>
<p>解决很简单：只要保证NSAttributedString中每一个字符的Attributes属性不一样就可以了。我开始的做法是添加一个自定义属性<code>kCJIndexAttributesName</code>，然后给每个字符存储不同的index值，并且在全部图文遍历绘制过一次后将<code>kCJIndexAttributesName</code>移除，这样在后续的重绘中就会减少<code>CTRun</code>的拆分数量，提高了效率。</p>
<p>然而，理想很美好，现实很打击。就算自定义属性<code>kCJIndexAttributesName</code>移除了，可<code>CTRun</code>还是会被拆分为单个字符，但是如果使用系统自带的属性则不会如此。无奈只能从系统方法中寻找解决思路，幸好发现了<code>NSLinkAttributeName</code>属性，这是UITextView中用来设置http链接的扩展属性，存储的对象是<code>NSURL</code>或<code>NSString</code>类型，而UILabel默认是不支持http链点的，使用<code>NSLinkAttributeName</code>属性可以最大限度的降低UILabel对默认NSAttributedString展示的影响。同时为了更好的判断计算，我将存储的对象改为NSURL的子类<code>CJCTRunUrl</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//给每一个字符设置index值，enableCopy=YES时生效</span><br>__block <span class="hljs-built_in">NSInteger</span> index = <span class="hljs-number">0</span>;<br>[attText.string enumerateSubstringsInRange:<span class="hljs-built_in">NSMakeRange</span>(<span class="hljs-number">0</span>, [attText length]) options:<span class="hljs-built_in">NSStringEnumerationByComposedCharacterSequences</span> usingBlock:<br> ^(<span class="hljs-built_in">NSString</span> *substring, <span class="hljs-built_in">NSRange</span> substringRange, <span class="hljs-built_in">NSRange</span> enclosingRange, <span class="hljs-built_in">BOOL</span> *stop) &#123;<br>     CJCTRunUrl *runUrl = <span class="hljs-literal">nil</span>;<br>     <span class="hljs-keyword">if</span> (!runUrl) &#123;<br>         <span class="hljs-built_in">NSString</span> *urlStr = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;https://www.CJLabel%@&quot;</span>,@(index)];<br>         runUrl = [CJCTRunUrl URLWithString:urlStr];<br>     &#125;<br>     runUrl.index = index;<br>     runUrl.rangeValue = [<span class="hljs-built_in">NSValue</span> valueWithRange:substringRange];<br>     [attText addAttribute:<span class="hljs-built_in">NSLinkAttributeName</span><br>                     value:runUrl<br>                     range:substringRange];<br>     index++;<br> &#125;];<br></code></pre></td></tr></table></figure>

<p>选择复制视图展示的交互逻辑则在双击或长按手势中实现，前面 <strong>点击响应</strong> 的伪代码示意中已经说明。另外讲解一下选择复制视图的实现细节：</p>
<p>其中的<code>拷贝、选择、全选</code>菜单使用系统提供的<code>UIMenuController</code>实现，在双击或长按时只要将它显示到手指点击对应的位置上就行。</p>
<p>放大镜则是自定义UIView，并在上面添加一个<code>CALayer</code>，再在<code>CALayer</code>上根据更新的点坐标做放大效果，<code>CALayer</code>的放大境处理逻辑如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objc">- (<span class="hljs-keyword">void</span>)drawInContext:(<span class="hljs-built_in">CGContextRef</span>)ctx &#123;<br>	<span class="hljs-built_in">CGContextTranslateCTM</span>(ctx, <span class="hljs-keyword">self</span>.frame.size.width/<span class="hljs-number">2</span>, <span class="hljs-keyword">self</span>.frame.size.height/<span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">CGContextScaleCTM</span>(ctx, <span class="hljs-number">1.40</span>, <span class="hljs-number">1.40</span>);<br>	<span class="hljs-comment">//self.pointToMagnify是更新的放大点坐标</span><br>	<span class="hljs-built_in">CGContextTranslateCTM</span>(ctx, <span class="hljs-number">-1</span> * <span class="hljs-keyword">self</span>.pointToMagnify.x, <span class="hljs-number">-1</span> * <span class="hljs-keyword">self</span>.pointToMagnify.y);<br>	[CJkeyWindow().layer renderInContext:ctx];<br>	CJkeyWindow().layer.contents = (<span class="hljs-keyword">id</span>)<span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大头针包含的提示用户选中区域，同样由自定义UIView实现，在自定义view上面填充颜色以及在起始结束位置画出大头针，其中的填充颜色区域包含三部分<code>headRect</code> <code>middleRect</code> <code>tailRect</code></p>
<p><img src="https://lele8446infoq.oss-cn-shenzhen.aliyuncs.com/%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F.png" alt="选择区域"></p>
<p>这三部分存在任意组合的情况，填充颜色的时候要对这三部分区分开来分别进行填充。因为有可能存在只有<code>headRect</code> <code>middleRect</code> 或只有<code>middleRect</code> <code>tailRect</code>，又或者只有 <code>middleRect</code> 的情况，而且填充颜色使用的是<code>CoreGraphics</code>中的绘图API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">CGContextRef</span> ctx = <span class="hljs-built_in">UIGraphicsGetCurrentContext</span>();<br><span class="hljs-comment">//填充的背景色</span><br><span class="hljs-built_in">UIColor</span> *backColor = CJUIRGBColor(<span class="hljs-number">0</span>,<span class="hljs-number">84</span>,<span class="hljs-number">166</span>,<span class="hljs-number">0.2</span>);<br>[backColor set];<br><span class="hljs-built_in">CGContextAddRect</span>(ctx, <span class="hljs-keyword">self</span>.headRect);<br><span class="hljs-built_in">CGContextStrokePath</span>(ctx);<br></code></pre></td></tr></table></figure>

<p>接下来便是如何显示这三个选择复制相关的视图了，一开始我只是简单的将它们添加到<code>Label</code>上面来统一管理，但这样会存在一个问题。那就是当页面中存在多个<code>Label</code>，并且对每个<code>Label</code>分别执行选择复制操作时，那么不同的<code>label</code>上都会出现选择复制视图，这是与系统的默认行为是不一致的。权衡之后将以上三个视图的显示作为单例处理，全局只初始化一次，避免了重复初始化的开销。并且将它添加到<code>UIWindow</code>层，这样在不同的<code>Label</code>之间进行选择复制时，也只会显示一个选择复制视图。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>以上便是iOS图文绘制原理以及自定义图文控件的说明，关键点是充分理解你看到的每一个字符在底层绘制显示的时候与<code>CTFrame</code> <code>CTLine</code> <code>CTRun</code>等实体类的对应关系，并借助其计算得到每一个字符的区域<code>frame</code>信息，有了区域<code>frame</code>信息便能够扩展实现各种自定义功能（点击响应、插入图片、选择拷贝等）。</p>
<p>全文完，更多的实现可以查看源码<a target="_blank" rel="noopener" href="https://github.com/lele8446/CJLabel">CJLabel</a>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Runtime/" rel="tag"># Runtime</a>
          
            <a href="/tags/CoreText/" rel="tag"># CoreText</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/iOS12%20%E8%B8%A9%E5%9D%91%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/" rel="next" title="iOS12 踩坑持续更新">
                <i class="fa fa-chevron-left"></i> iOS12 踩坑持续更新
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/%E6%8E%A7%E5%88%B6UIScrollView%E6%BB%91%E5%8A%A8%E6%96%B9%E5%90%91%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="prev" title="控制UIScrollView滑动方向解决方案">
                控制UIScrollView滑动方向解决方案 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lele8446" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-fab fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/a97f1b616991" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-fab fa-book"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lele8446@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-fab fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/in/%E7%82%BD%E9%87%91-%E7%BB%83-966a4813b/" target="_blank" title="Linkedin">
                      
                        <i class="fa fa-fw fa-fab fa-linkedin"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%96%87%E7%BB%98%E5%88%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">图文绘制架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoreGraphics"><span class="nav-number">2.</span> <span class="nav-text">CoreGraphics</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoreText%E6%A1%86%E6%9E%B6"><span class="nav-number">3.</span> <span class="nav-text">CoreText框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFramesetter"><span class="nav-number">3.1.</span> <span class="nav-text">CTFramesetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFrame"><span class="nav-number">3.2.</span> <span class="nav-text">CTFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTLine"><span class="nav-number">3.3.</span> <span class="nav-text">CTLine</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTRun"><span class="nav-number">3.4.</span> <span class="nav-text">CTRun</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTRunDelegate"><span class="nav-number">3.5.</span> <span class="nav-text">CTRunDelegate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%E6%8E%A7%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">自定义图文混排控件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%98%E5%88%B6%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.</span> <span class="nav-text">绘制关键点说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E5%87%BB%E5%93%8D%E5%BA%94"><span class="nav-number">4.2.</span> <span class="nav-text">点击响应</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E3%80%81%E5%A4%8D%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">选择、复制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-number">5.</span> <span class="nav-text">写在最后</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ChiJin.Lian    粤公网安备 44030602006855号</span>

  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
